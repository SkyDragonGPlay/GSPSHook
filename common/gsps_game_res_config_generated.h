// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_GSPSGAMERESCONFIG_SKYDRAGON_H_
#define FLATBUFFERS_GENERATED_GSPSGAMERESCONFIG_SKYDRAGON_H_

#include "flatbuffers/flatbuffers.h"

namespace SkyDragon {

struct ResBundle;

struct UpdatePatch;

struct DeleteFileList;

struct GameResConfig;

struct ResBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_SIZE = 6,
    VT_MD5 = 8,
    VT_FILES = 10
  };
  const flatbuffers::String *path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  int32_t size() const { return GetField<int32_t>(VT_SIZE, 0); }
  const flatbuffers::String *md5() const { return GetPointer<const flatbuffers::String *>(VT_MD5); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MD5) &&
           verifier.Verify(md5()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILES) &&
           verifier.Verify(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           verifier.EndTable();
  }
};

struct ResBundleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) { fbb_.AddOffset(ResBundle::VT_PATH, path); }
  void add_size(int32_t size) { fbb_.AddElement<int32_t>(ResBundle::VT_SIZE, size, 0); }
  void add_md5(flatbuffers::Offset<flatbuffers::String> md5) { fbb_.AddOffset(ResBundle::VT_MD5, md5); }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) { fbb_.AddOffset(ResBundle::VT_FILES, files); }
  ResBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ResBundleBuilder &operator=(const ResBundleBuilder &);
  flatbuffers::Offset<ResBundle> Finish() {
    auto o = flatbuffers::Offset<ResBundle>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<ResBundle> CreateResBundle(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    int32_t size = 0,
    flatbuffers::Offset<flatbuffers::String> md5 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0) {
  ResBundleBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_md5(md5);
  builder_.add_size(size);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResBundle> CreateResBundleDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    int32_t size = 0,
    const char *md5 = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr) {
  return CreateResBundle(_fbb, path ? _fbb.CreateString(path) : 0, size, md5 ? _fbb.CreateString(md5) : 0, files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0);
}

struct UpdatePatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOR_VERSION = 4,
    VT_PATH = 6,
    VT_MD5 = 8,
    VT_SIZE = 10
  };
  int16_t for_version() const { return GetField<int16_t>(VT_FOR_VERSION, 0); }
  const flatbuffers::String *path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  const flatbuffers::String *md5() const { return GetPointer<const flatbuffers::String *>(VT_MD5); }
  int32_t size() const { return GetField<int32_t>(VT_SIZE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FOR_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MD5) &&
           verifier.Verify(md5()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct UpdatePatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_for_version(int16_t for_version) { fbb_.AddElement<int16_t>(UpdatePatch::VT_FOR_VERSION, for_version, 0); }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) { fbb_.AddOffset(UpdatePatch::VT_PATH, path); }
  void add_md5(flatbuffers::Offset<flatbuffers::String> md5) { fbb_.AddOffset(UpdatePatch::VT_MD5, md5); }
  void add_size(int32_t size) { fbb_.AddElement<int32_t>(UpdatePatch::VT_SIZE, size, 0); }
  UpdatePatchBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UpdatePatchBuilder &operator=(const UpdatePatchBuilder &);
  flatbuffers::Offset<UpdatePatch> Finish() {
    auto o = flatbuffers::Offset<UpdatePatch>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<UpdatePatch> CreateUpdatePatch(flatbuffers::FlatBufferBuilder &_fbb,
    int16_t for_version = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    flatbuffers::Offset<flatbuffers::String> md5 = 0,
    int32_t size = 0) {
  UpdatePatchBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_md5(md5);
  builder_.add_path(path);
  builder_.add_for_version(for_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpdatePatch> CreateUpdatePatchDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int16_t for_version = 0,
    const char *path = nullptr,
    const char *md5 = nullptr,
    int32_t size = 0) {
  return CreateUpdatePatch(_fbb, for_version, path ? _fbb.CreateString(path) : 0, md5 ? _fbb.CreateString(md5) : 0, size);
}

struct DeleteFileList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FOR_VERSION = 4,
    VT_FILES = 6
  };
  int16_t for_version() const { return GetField<int16_t>(VT_FOR_VERSION, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FOR_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILES) &&
           verifier.Verify(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           verifier.EndTable();
  }
};

struct DeleteFileListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_for_version(int16_t for_version) { fbb_.AddElement<int16_t>(DeleteFileList::VT_FOR_VERSION, for_version, 0); }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) { fbb_.AddOffset(DeleteFileList::VT_FILES, files); }
  DeleteFileListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DeleteFileListBuilder &operator=(const DeleteFileListBuilder &);
  flatbuffers::Offset<DeleteFileList> Finish() {
    auto o = flatbuffers::Offset<DeleteFileList>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DeleteFileList> CreateDeleteFileList(flatbuffers::FlatBufferBuilder &_fbb,
    int16_t for_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0) {
  DeleteFileListBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_for_version(for_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeleteFileList> CreateDeleteFileListDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int16_t for_version = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr) {
  return CreateDeleteFileList(_fbb, for_version, files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0);
}

struct GameResConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RES_VERSION = 4,
    VT_RES_BUNDLES = 6,
    VT_UPDATE_PATCHS = 8,
    VT_DELETE_FILE_LIST = 10
  };
  int16_t res_version() const { return GetField<int16_t>(VT_RES_VERSION, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<ResBundle>> *res_bundles() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResBundle>> *>(VT_RES_BUNDLES); }
  const flatbuffers::Vector<flatbuffers::Offset<UpdatePatch>> *update_patchs() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UpdatePatch>> *>(VT_UPDATE_PATCHS); }
  const flatbuffers::Vector<flatbuffers::Offset<DeleteFileList>> *delete_file_list() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeleteFileList>> *>(VT_DELETE_FILE_LIST); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_RES_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RES_BUNDLES) &&
           verifier.Verify(res_bundles()) &&
           verifier.VerifyVectorOfTables(res_bundles()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UPDATE_PATCHS) &&
           verifier.Verify(update_patchs()) &&
           verifier.VerifyVectorOfTables(update_patchs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DELETE_FILE_LIST) &&
           verifier.Verify(delete_file_list()) &&
           verifier.VerifyVectorOfTables(delete_file_list()) &&
           verifier.EndTable();
  }
};

struct GameResConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_res_version(int16_t res_version) { fbb_.AddElement<int16_t>(GameResConfig::VT_RES_VERSION, res_version, 0); }
  void add_res_bundles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResBundle>>> res_bundles) { fbb_.AddOffset(GameResConfig::VT_RES_BUNDLES, res_bundles); }
  void add_update_patchs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UpdatePatch>>> update_patchs) { fbb_.AddOffset(GameResConfig::VT_UPDATE_PATCHS, update_patchs); }
  void add_delete_file_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeleteFileList>>> delete_file_list) { fbb_.AddOffset(GameResConfig::VT_DELETE_FILE_LIST, delete_file_list); }
  GameResConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameResConfigBuilder &operator=(const GameResConfigBuilder &);
  flatbuffers::Offset<GameResConfig> Finish() {
    auto o = flatbuffers::Offset<GameResConfig>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<GameResConfig> CreateGameResConfig(flatbuffers::FlatBufferBuilder &_fbb,
    int16_t res_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResBundle>>> res_bundles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UpdatePatch>>> update_patchs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeleteFileList>>> delete_file_list = 0) {
  GameResConfigBuilder builder_(_fbb);
  builder_.add_delete_file_list(delete_file_list);
  builder_.add_update_patchs(update_patchs);
  builder_.add_res_bundles(res_bundles);
  builder_.add_res_version(res_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameResConfig> CreateGameResConfigDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int16_t res_version = 0,
    const std::vector<flatbuffers::Offset<ResBundle>> *res_bundles = nullptr,
    const std::vector<flatbuffers::Offset<UpdatePatch>> *update_patchs = nullptr,
    const std::vector<flatbuffers::Offset<DeleteFileList>> *delete_file_list = nullptr) {
  return CreateGameResConfig(_fbb, res_version, res_bundles ? _fbb.CreateVector<flatbuffers::Offset<ResBundle>>(*res_bundles) : 0, update_patchs ? _fbb.CreateVector<flatbuffers::Offset<UpdatePatch>>(*update_patchs) : 0, delete_file_list ? _fbb.CreateVector<flatbuffers::Offset<DeleteFileList>>(*delete_file_list) : 0);
}

inline const SkyDragon::GameResConfig *GetGameResConfig(const void *buf) { return flatbuffers::GetRoot<SkyDragon::GameResConfig>(buf); }

inline bool VerifyGameResConfigBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<SkyDragon::GameResConfig>(nullptr); }

inline void FinishGameResConfigBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<SkyDragon::GameResConfig> root) { fbb.Finish(root); }

}  // namespace SkyDragon

#endif  // FLATBUFFERS_GENERATED_GSPSGAMERESCONFIG_SKYDRAGON_H_
