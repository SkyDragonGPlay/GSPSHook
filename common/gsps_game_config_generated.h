// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_GSPSGAMECONFIG_SKYDRAGON_H_
#define FLATBUFFERS_GENERATED_GSPSGAMECONFIG_SKYDRAGON_H_

#include "flatbuffers/flatbuffers.h"

namespace SkyDragon {

struct LatestResConfig;

struct GameConfig;

struct LatestResConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARCHIVE_PATH = 4,
    VT_ARCHIVE_SIZE = 6,
    VT_ARCHIVE_MD5 = 8,
    VT_RES_BUNDLES_CONFIG = 10
  };
  const flatbuffers::String *archive_path() const { return GetPointer<const flatbuffers::String *>(VT_ARCHIVE_PATH); }
  int32_t archive_size() const { return GetField<int32_t>(VT_ARCHIVE_SIZE, 0); }
  const flatbuffers::String *archive_md5() const { return GetPointer<const flatbuffers::String *>(VT_ARCHIVE_MD5); }
  const flatbuffers::String *res_bundles_config() const { return GetPointer<const flatbuffers::String *>(VT_RES_BUNDLES_CONFIG); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ARCHIVE_PATH) &&
           verifier.Verify(archive_path()) &&
           VerifyField<int32_t>(verifier, VT_ARCHIVE_SIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ARCHIVE_MD5) &&
           verifier.Verify(archive_md5()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RES_BUNDLES_CONFIG) &&
           verifier.Verify(res_bundles_config()) &&
           verifier.EndTable();
  }
};

struct LatestResConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_archive_path(flatbuffers::Offset<flatbuffers::String> archive_path) { fbb_.AddOffset(LatestResConfig::VT_ARCHIVE_PATH, archive_path); }
  void add_archive_size(int32_t archive_size) { fbb_.AddElement<int32_t>(LatestResConfig::VT_ARCHIVE_SIZE, archive_size, 0); }
  void add_archive_md5(flatbuffers::Offset<flatbuffers::String> archive_md5) { fbb_.AddOffset(LatestResConfig::VT_ARCHIVE_MD5, archive_md5); }
  void add_res_bundles_config(flatbuffers::Offset<flatbuffers::String> res_bundles_config) { fbb_.AddOffset(LatestResConfig::VT_RES_BUNDLES_CONFIG, res_bundles_config); }
  LatestResConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LatestResConfigBuilder &operator=(const LatestResConfigBuilder &);
  flatbuffers::Offset<LatestResConfig> Finish() {
    auto o = flatbuffers::Offset<LatestResConfig>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<LatestResConfig> CreateLatestResConfig(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> archive_path = 0,
    int32_t archive_size = 0,
    flatbuffers::Offset<flatbuffers::String> archive_md5 = 0,
    flatbuffers::Offset<flatbuffers::String> res_bundles_config = 0) {
  LatestResConfigBuilder builder_(_fbb);
  builder_.add_res_bundles_config(res_bundles_config);
  builder_.add_archive_md5(archive_md5);
  builder_.add_archive_size(archive_size);
  builder_.add_archive_path(archive_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<LatestResConfig> CreateLatestResConfigDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *archive_path = nullptr,
    int32_t archive_size = 0,
    const char *archive_md5 = nullptr,
    const char *res_bundles_config = nullptr) {
  return CreateLatestResConfig(_fbb, archive_path ? _fbb.CreateString(archive_path) : 0, archive_size, archive_md5 ? _fbb.CreateString(archive_md5) : 0, res_bundles_config ? _fbb.CreateString(res_bundles_config) : 0);
}

struct GameConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GAME_VERSION_CODE = 4,
    VT_GAME_VERSION_NAME = 6,
    VT_ORIENTATION = 8,
    VT_ENGINE = 10,
    VT_ENGINE_VERSION = 12,
    VT_GAME_TYPE = 14,
    VT_LATEST_RES_VERSION = 16,
    VT_LATEST_RES_CONFIGS = 18
  };
  int32_t game_version_code() const { return GetField<int32_t>(VT_GAME_VERSION_CODE, 0); }
  const flatbuffers::String *game_version_name() const { return GetPointer<const flatbuffers::String *>(VT_GAME_VERSION_NAME); }
  const flatbuffers::String *orientation() const { return GetPointer<const flatbuffers::String *>(VT_ORIENTATION); }
  const flatbuffers::String *engine() const { return GetPointer<const flatbuffers::String *>(VT_ENGINE); }
  const flatbuffers::String *engine_version() const { return GetPointer<const flatbuffers::String *>(VT_ENGINE_VERSION); }
  const flatbuffers::String *game_type() const { return GetPointer<const flatbuffers::String *>(VT_GAME_TYPE); }
  int16_t latest_res_version() const { return GetField<int16_t>(VT_LATEST_RES_VERSION, 0); }
  const LatestResConfig *latest_res_configs() const { return GetPointer<const LatestResConfig *>(VT_LATEST_RES_CONFIGS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GAME_VERSION_CODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_GAME_VERSION_NAME) &&
           verifier.Verify(game_version_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ORIENTATION) &&
           verifier.Verify(orientation()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ENGINE) &&
           verifier.Verify(engine()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ENGINE_VERSION) &&
           verifier.Verify(engine_version()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_GAME_TYPE) &&
           verifier.Verify(game_type()) &&
           VerifyField<int16_t>(verifier, VT_LATEST_RES_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LATEST_RES_CONFIGS) &&
           verifier.VerifyTable(latest_res_configs()) &&
           verifier.EndTable();
  }
};

struct GameConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_game_version_code(int32_t game_version_code) { fbb_.AddElement<int32_t>(GameConfig::VT_GAME_VERSION_CODE, game_version_code, 0); }
  void add_game_version_name(flatbuffers::Offset<flatbuffers::String> game_version_name) { fbb_.AddOffset(GameConfig::VT_GAME_VERSION_NAME, game_version_name); }
  void add_orientation(flatbuffers::Offset<flatbuffers::String> orientation) { fbb_.AddOffset(GameConfig::VT_ORIENTATION, orientation); }
  void add_engine(flatbuffers::Offset<flatbuffers::String> engine) { fbb_.AddOffset(GameConfig::VT_ENGINE, engine); }
  void add_engine_version(flatbuffers::Offset<flatbuffers::String> engine_version) { fbb_.AddOffset(GameConfig::VT_ENGINE_VERSION, engine_version); }
  void add_game_type(flatbuffers::Offset<flatbuffers::String> game_type) { fbb_.AddOffset(GameConfig::VT_GAME_TYPE, game_type); }
  void add_latest_res_version(int16_t latest_res_version) { fbb_.AddElement<int16_t>(GameConfig::VT_LATEST_RES_VERSION, latest_res_version, 0); }
  void add_latest_res_configs(flatbuffers::Offset<LatestResConfig> latest_res_configs) { fbb_.AddOffset(GameConfig::VT_LATEST_RES_CONFIGS, latest_res_configs); }
  GameConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameConfigBuilder &operator=(const GameConfigBuilder &);
  flatbuffers::Offset<GameConfig> Finish() {
    auto o = flatbuffers::Offset<GameConfig>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<GameConfig> CreateGameConfig(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t game_version_code = 0,
    flatbuffers::Offset<flatbuffers::String> game_version_name = 0,
    flatbuffers::Offset<flatbuffers::String> orientation = 0,
    flatbuffers::Offset<flatbuffers::String> engine = 0,
    flatbuffers::Offset<flatbuffers::String> engine_version = 0,
    flatbuffers::Offset<flatbuffers::String> game_type = 0,
    int16_t latest_res_version = 0,
    flatbuffers::Offset<LatestResConfig> latest_res_configs = 0) {
  GameConfigBuilder builder_(_fbb);
  builder_.add_latest_res_configs(latest_res_configs);
  builder_.add_game_type(game_type);
  builder_.add_engine_version(engine_version);
  builder_.add_engine(engine);
  builder_.add_orientation(orientation);
  builder_.add_game_version_name(game_version_name);
  builder_.add_game_version_code(game_version_code);
  builder_.add_latest_res_version(latest_res_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameConfig> CreateGameConfigDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t game_version_code = 0,
    const char *game_version_name = nullptr,
    const char *orientation = nullptr,
    const char *engine = nullptr,
    const char *engine_version = nullptr,
    const char *game_type = nullptr,
    int16_t latest_res_version = 0,
    flatbuffers::Offset<LatestResConfig> latest_res_configs = 0) {
  return CreateGameConfig(_fbb, game_version_code, game_version_name ? _fbb.CreateString(game_version_name) : 0, orientation ? _fbb.CreateString(orientation) : 0, engine ? _fbb.CreateString(engine) : 0, engine_version ? _fbb.CreateString(engine_version) : 0, game_type ? _fbb.CreateString(game_type) : 0, latest_res_version, latest_res_configs);
}

inline const SkyDragon::GameConfig *GetGameConfig(const void *buf) { return flatbuffers::GetRoot<SkyDragon::GameConfig>(buf); }

inline bool VerifyGameConfigBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<SkyDragon::GameConfig>(nullptr); }

inline void FinishGameConfigBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<SkyDragon::GameConfig> root) { fbb.Finish(root); }

}  // namespace SkyDragon

#endif  // FLATBUFFERS_GENERATED_GSPSGAMECONFIG_SKYDRAGON_H_
